module Language.PureScript.Erl.Make where

import Prelude

import           Control.Monad hiding (sequence)
import           Control.Monad.Error.Class (MonadError(..))
import           Control.Monad.IO.Class
import           Control.Monad.Reader (asks)
import           Control.Monad.Supply
import           Control.Monad.Trans.Class (MonadTrans(..))
import           Control.Monad.Writer.Class (MonadWriter(..))
import qualified Language.PureScript.CoreFn as CF
import           Language.PureScript.Externs (ExternsFile)
import           Language.PureScript.Make.Monad
import qualified Language.PureScript as P
import           Control.Monad.Supply
import qualified Data.Map as M
import           Language.PureScript.Erl.Parser (parseFile)
import qualified Data.Text as T
import qualified Data.Text.Encoding as TE
import           System.FilePath ((</>), makeRelative, splitPath, normalise)
import           Data.Foldable (for_, minimum)
import           System.Directory (getCurrentDirectory)
import           Data.Version (showVersion)

import qualified Paths_purerl as Paths

import           Language.PureScript.Erl.CodeGen.Common (erlModuleName, atomModuleName, atom, ModuleType(..))
import           Language.PureScript.Erl.CodeGen (moduleToErl)
import           Language.PureScript.Erl.Pretty (prettyPrintErl)



data MakeActions m = MakeActions
  { codegen :: CF.Module CF.Ann -> SupplyT m ()
  -- ^ Run the code generator for the module and write any required output files.
  , ffiCodegen :: CF.Module CF.Ann -> m ()
  }

buildActions :: String -> P.Environment -> M.Map P.ModuleName FilePath -> Bool -> MakeActions Make
buildActions outputDir env foreigns usePrefix =
  MakeActions codegen ffiCodegen 
  where

  codegen :: CF.Module CF.Ann -> SupplyT Make ()
  codegen m = do
    let mn = CF.moduleName m
    foreignExports <- lift $ case mn `M.lookup` foreigns of
      Just path
        | not $ requiresForeign m ->
            return []
        | otherwise -> getForeigns path
      Nothing ->
        return []

    (exports, rawErl) <- moduleToErl env m foreignExports 
    dir <- lift $ makeIO "get file info: ." getCurrentDirectory
    let makeAbsFile file = dir </> file
    let pretty = prettyPrintErl (makeAbsFile :: String -> String) rawErl
    let moduleDir = outputDir </> T.unpack (P.runModuleName mn)
        outFile = moduleDir </> T.unpack (erlModuleName mn PureScriptModule) ++ ".erl"
        prefix :: [T.Text]
        prefix = ["Generated by purs version " <> T.pack (showVersion Paths.version) | usePrefix]
        directives :: [T.Text]
        directives = [
          "-module(" <> atom (atomModuleName mn PureScriptModule) <> ").",
          "-export([" <> T.intercalate ", " exports <> "]).",
          "-compile(nowarn_shadow_vars).",
          "-compile(nowarn_unused_vars).",  -- consider using _ vars
          "-compile(no_auto_import)."
          ]
    let erl :: T.Text = T.unlines $ map ("% " <>) prefix ++ directives ++ [ pretty ]
    lift $ writeTextFile outFile $ TE.encodeUtf8 erl

  ffiCodegen :: CF.Module CF.Ann -> Make ()
  ffiCodegen m = do
    let mn = CF.moduleName m
        moduleDir = outputDir </> T.unpack (P.runModuleName mn)
        foreignFile = moduleDir </> T.unpack (erlModuleName mn ForeignModule) ++ ".erl"
    case mn `M.lookup` foreigns of
      Just path
        | not $ requiresForeign m ->
            tell $ P.errorMessage $ P.UnnecessaryFFIModule mn path
        | otherwise -> pure ()
      Nothing ->
        when (requiresForeign m) $ throwError . P.errorMessage $ P.MissingFFIModule mn
    for_ (mn `M.lookup` foreigns) $ \path ->
      copyFile path foreignFile

  requiresForeign :: CF.Module a -> Bool
  requiresForeign = not . null . CF.moduleForeign

  getForeigns :: String -> Make [(T.Text, Int)]
  getForeigns path = do
    text <- readTextFile path
    pure $ either (const []) id $ parseFile path text